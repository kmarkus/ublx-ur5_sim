/*
 * mypid microblx function block (autogenerated, don't edit)
 */

#include <ubx.h>

UBX_MODULE_LICENSE_SPDX(BSD-3-Clause)

/* includes types and type metadata */

ubx_type_t types[] = {
};

/* block meta information */
char mypid_meta[] =
	" { doc='',"
	"   realtime=true,"
	"}";

/* declaration of block configuration */
ubx_proto_config_t mypid_config[] = {
	{ .name="Kp", .type_name = "double", .min=0, .max=0, .doc="P-gain (def: 0)" },
	{ .name="Ki", .type_name = "double", .min=0, .max=0, .doc="I-gain (def: 0)" },
	{ .name="Kd", .type_name = "double", .min=0, .max=0, .doc="D-gain (def: 0)" },
	{ .name="data_len", .type_name = "unsigned int", .min=0, .max=0, .doc="length of signal array (def: 1)" },
	{ 0 },
};

/* declaration port block ports */
ubx_proto_port_t mypid_ports[] = {
	{ .name="msr"    , .in_type_name="double", .in_data_len=1, .doc="measured input signal"  },
	{ .name="msr_dot", .in_type_name="double", .in_data_len=1, .doc="measured input signal"  },
	{ .name="des"    , .in_type_name="double", .in_data_len=1, .doc="desired input signal"  },
	{ .name="des_dot", .in_type_name="double", .in_data_len=1, .doc="desired input signal"  },
	{ .name="out"    , .out_type_name="double", .out_data_len=1, .doc="controller output"  },
	{ 0 },
};

/* declare a struct port_cache */
struct mypid_port_cache {
	ubx_port_t* msr;
	ubx_port_t* msr_dot;
	ubx_port_t* des;
	ubx_port_t* des_dot;
	ubx_port_t* out;
};

/* helper function to cache ports. call in init */
static void update_port_cache(ubx_block_t *b, struct mypid_port_cache *pc)
{
	pc->msr = ubx_port_get(b, "msr");
	pc->msr_dot = ubx_port_get(b, "msr_dot");
	pc->des = ubx_port_get(b, "des");
	pc->des_dot = ubx_port_get(b, "des_dot");
	pc->out = ubx_port_get(b, "out");
}

/* define safe accessors for the new types */


/* block operation forward declarations */
int mypid_init(ubx_block_t *b);
int mypid_start(ubx_block_t *b);
void mypid_stop(ubx_block_t *b);
void mypid_cleanup(ubx_block_t *b);
void mypid_step(ubx_block_t *b);

ubx_proto_block_t mypid_block = {
	.name = "mypid",
	.type = BLOCK_TYPE_COMPUTATION,
	.meta_data = mypid_meta,
	.configs = mypid_config,
	.ports = mypid_ports,

	/* ops */
	.init = mypid_init,
	.start = mypid_start,
	.stop = mypid_stop,
	.cleanup = mypid_cleanup,
	.step = mypid_step,
};


/* mypid module init and cleanup functions */
int mypid_mod_init(ubx_node_t* nd)
{
	ubx_log(UBX_LOGLEVEL_DEBUG, nd, "%s", __func__);

	for (unsigned int i=0; i<ARRAY_SIZE(types); i++) {
		if(ubx_type_register(nd, &types[i]) != 0)
			return -1;
	}

	if(ubx_block_register(nd, &mypid_block) != 0)
		return -1;

	return 0;
}

void mypid_mod_cleanup(ubx_node_t *nd)
{
	ubx_log(UBX_LOGLEVEL_DEBUG, nd, "%s", __func__);

	for (unsigned int i=0; i<ARRAY_SIZE(types); i++)
		ubx_type_unregister(nd, types[i].name);

	ubx_block_unregister(nd, "mypid");
}

/* declare module init and cleanup functions, so that the ubx core can
 * find these when the module is loaded/unloaded */
UBX_MODULE_INIT(mypid_mod_init)
UBX_MODULE_CLEANUP(mypid_mod_cleanup)
