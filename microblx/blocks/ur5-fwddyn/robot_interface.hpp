/*
 * robot_interface microblx function block (autogenerated, don't edit)
 */

#include <ubx.h>

UBX_MODULE_LICENSE_SPDX(BSD 3-Clause)

/* includes types and type metadata */

ubx_type_t types[] = {
};

/* block meta information */
char robot_interface_meta[] =
	" { doc='',"
	"   realtime=true,"
	"}";

/* declaration of block configuration */
ubx_proto_config_t robot_interface_config[] = {
	{ .name="joint_state_size", .type_name = "int", .min=1, .max=0, .doc="number of degrees of freedom" },
	{ .name="misc_sensors_count", .type_name = "int", .min=0, .max=0, .doc="number of miscellaneous sensed quantities on the robot" },
	{ 0 },
};

/* declaration port block ports */
ubx_proto_port_t robot_interface_ports[] = {
	{ .name="q", .out_type_name="double", .out_data_len=1, .doc="joint status vector"  },
	{ .name="qd", .out_type_name="double", .out_data_len=1, .doc="joint velocity vector"  },
	{ .name="load", .out_type_name="double", .out_data_len=1, .doc="measured joint effort"  },
	{ .name="misc_sensors", .out_type_name="double", .out_data_len=1, .doc="miscellaneous sensor inputs"  },
	{ .name="tau", .in_type_name="double", .in_data_len=1, .doc="joint force command"  },
	{ .name="time", .out_type_name="double", .out_data_len=1, .doc="physical time flow (in usecs)"  },
	{ 0 },
};

/* declare a struct port_cache */
struct robot_interface_port_cache {
	ubx_port_t* q;
	ubx_port_t* qd;
	ubx_port_t* load;
	ubx_port_t* misc_sensors;
	ubx_port_t* tau;
	ubx_port_t* time;
};

/* helper function to cache ports. call in init */
static void update_port_cache(ubx_block_t *b, struct robot_interface_port_cache *pc)
{
	pc->q = ubx_port_get(b, "q");
	pc->qd = ubx_port_get(b, "qd");
	pc->load = ubx_port_get(b, "load");
	pc->misc_sensors = ubx_port_get(b, "misc_sensors");
	pc->tau = ubx_port_get(b, "tau");
	pc->time = ubx_port_get(b, "time");
}

/* define safe accessors for the new types */


/* block operation forward declarations */
int robot_interface_init(ubx_block_t *b);
int robot_interface_start(ubx_block_t *b);
void robot_interface_stop(ubx_block_t *b);
void robot_interface_cleanup(ubx_block_t *b);
void robot_interface_step(ubx_block_t *b);

ubx_proto_block_t robot_interface_block = {
	.name = "robot_interface",
	.meta_data = robot_interface_meta,
	.type = BLOCK_TYPE_COMPUTATION,
	.configs = robot_interface_config,
	.ports = robot_interface_ports,

	/* ops */
	.init = robot_interface_init,
	.start = robot_interface_start,
	.stop = robot_interface_stop,
	.cleanup = robot_interface_cleanup,
	.step = robot_interface_step,
};


/* robot_interface module init and cleanup functions */
int robot_interface_mod_init(ubx_node_t* nd)
{
	for (unsigned int i=0; i<ARRAY_SIZE(types); i++) {
		if(ubx_type_register(nd, &types[i]) != 0)
			return -1;
	}

	if(ubx_block_register(nd, &robot_interface_block) != 0)
		return -1;

	return 0;
}

void robot_interface_mod_cleanup(ubx_node_t *nd)
{
	for (unsigned int i=0; i<ARRAY_SIZE(types); i++)
		ubx_type_unregister(nd, types[i].name);

	ubx_block_unregister(nd, "robot_interface");
}

/* declare module init and cleanup functions, so that the ubx core can
 * find these when the module is loaded/unloaded */
UBX_MODULE_INIT(robot_interface_mod_init)
UBX_MODULE_CLEANUP(robot_interface_mod_cleanup)
